collections v3
==============

Collection
----------
owner = models.ForeignKey(settings.AUTH_USER_MODEL,related_name='collections', on_delete=models.CASCADE)
group = models.ForeignKey("CollectionGroup", db_column='group',related_name="group", null=True, blank=True, on_delete=models.PROTECT)
datasets = models.ManyToManyField('datasets.Dataset', through='collection.CollDataset', related_name='new_datasets', blank=True)
places = models.ManyToManyField("places.Place", through='CollPlace', blank=True)

contact = models.CharField(null=True, blank=True, max_length=500)
collection_class = models.CharField(choices=COLLECTIONCLASSES, max_length=12)
create_date = models.DateTimeField(null=True, auto_now_add=True)
creator = models.CharField(null=True, blank=True, max_length=500)
description = models.TextField(max_length=3000)
featured = models.IntegerField(null=True, blank=True)
file = models.FileField(upload_to=collection_path, blank=True, null=True)
image_file = ResizedImageField(size=[800, 600], upload_to=collection_path, blank=True, null=True)
keywords = ArrayField(models.CharField(max_length=50), null=True)
nominated = models.BooleanField(default=False)
nominate_date = models.DateTimeField(null=True, blank=True)
public = models.BooleanField(default=False)
rel_keywords = ArrayField(models.CharField(max_length=30), blank=True, null=True)
status = models.CharField(max_length=12, choices=STATUS_COLL, default='sandbox', null=True, blank=True)
submit_date = models.DateTimeField(null=True, blank=True)
title = models.CharField(null=False, max_length=255)
version = models.CharField(null=True, blank=True, max_length=20)
vis_parameters = JSONField(default=dict, null=True, blank=True)
webpage = models.URLField(null=True, blank=True)


  def carousel_metadata(self):
    return carousel_metadata(self)

  @property
  def clustered_geometries(self):
    return clustered_geometries(self)

  @property
  def collaborators(self):
    # includes roles: member, owner
    team = CollectionUser.objects.filter(collection_id = self.id).values_list('user_id')
    teamusers = User.objects.filter(id__in=team)
    return teamusers

  # download time estimate
  @property
  def dl_est(self):
    # Get the number of associated Place records
    num_records = self.places_all.count()

    # Calculate the estimated download time in seconds
    # (20 seconds per 1000 records)
    est_time_in_sec = (num_records / 1000) * 20

    # Convert the estimated time to minutes and seconds
    min, sec = divmod(est_time_in_sec, 60)

    # Format the result
    if min < 1:
      result = "%02d sec" % (sec)
    elif sec >= 10:
      result = "%02d min %02d sec" % (min, sec)
    else:
      result = "%02d min" % (min)

    return result

  @property
  def ds_counter(self):
    from collections import Counter
    from itertools import chain
    dc = self.datasets.all().values_list('label', flat=True)
    dp = self.places.all().values_list('dataset', flat=True)
    all = Counter(list(chain(dc, dp)))
    return dict(all)

  @property
  def ds_list(self):
    if self.collection_class == 'dataset':
      dsc = [{"id": d.id, "label": d.label, "extent": d.extent, "bounds": d.bounds, "title": d.title, "dl_est": d.dl_est,
              "numrows": d.numrows, "modified": d.last_modified_text} for d in self.datasets.all()]
      return list({item['id']: item for item in dsc}.values())
    elif self.collection_class == 'place':
      # Get all distinct datasets associated with all the places in the collection
      datasets = set(place.dataset for place in self.places.all())
      dsp = [{"id": d.id, "label": d.label, "title": d.title,
              "modified": d.last_modified_text} for d in datasets]
      return list({item['id']: item for item in dsp}.values())

  @property
  def feature_collection(self):
    return feature_collection(self)

  @property
  def heatmapped_geometries(self):
    return heatmapped_geometries(self)

  @property
  def hull_geometries(self):
    return hull_geometries(self)

  @property
  def kw_colors(self):
    colors = ['orange', 'red', 'green', 'blue', 'purple',
      'red', 'green', 'blue', 'purple']
    return dict(zip(self.rel_keywords, colors))

  @property
  def last_modified_iso(self):
    # TODO: log entries for collections
    return self.create_date.strftime("%Y-%m-%d")

  @property
  def owners(self):
    owner_ids = list(CollectionUser.objects.filter(collection=self, role='owner').values_list('user_id',flat=True))
    owner_ids.append(self.owner.id)
    owners = User.objects.filter(id__in=owner_ids)
    return owners

  @property
  def places_ds(self):
    dses = self.datasets.all()
    return Place.objects.filter(dataset__in=dses)

  @property
  def places_thru(self):
    seq_places = [{'p':cp.place,'seq':cp.sequence} for cp in CollPlace.objects.filter(collection=self.id).order_by('sequence')]
    return seq_places

  @property
  def places_all(self):
    all = Place.objects.filter(
      Q(dataset__in=self.datasets.all()) | Q(id__in=self.places.all().values_list('id'))
    )
    return all
    # return all.exclude(id__in=self.omitted)

  @property
  def rowcount(self):
    dses = self.datasets.all()
    ds_counts = [ds.places.count() for ds in dses]
    return sum(ds_counts) + self.places.count()


CollDataset
-----------
collection = models.ForeignKey('Collection', on_delete=models.CASCADE)
dataset = models.ForeignKey('datasets.Dataset', on_delete=models.CASCADE)
date_added = models.DateTimeField(default=timezone.now)

CollectionGroup
---------------
owner = models.ForeignKey(settings.AUTH_USER_MODEL,related_name='collection_groups', on_delete=models.CASCADE)
title = models.CharField(null=False, max_length=300)
description = models.TextField(null=True, max_length=3000)
type = models.CharField(choices=COLLECTIONGROUP_TYPES, default="class", max_length=8)
keywords = ArrayField(models.CharField(max_length=50), null=True)
# e.g. an essay
file = models.FileField(upload_to=collectiongroup_path, blank=True, null=True)
created = models.DateTimeField(auto_now_add=True)
start_date = models.DateTimeField(null=True)
due_date = models.DateTimeField(null=True)

# a Collection can belong to >=1 CollectionGroup
collections = models.ManyToManyField("collection.Collection", blank=True)

# group options
gallery = models.BooleanField(null=False, default=False)
gallery_required = models.BooleanField(null=False, default=False)
collaboration = models.BooleanField(null=False, default=False)
join_code = models.CharField(null=True, unique=True, max_length=20)

CollectionGroupUser
-------------------
collectiongroup = models.ForeignKey(CollectionGroup, related_name='members', default=-1, on_delete=models.CASCADE)
user = models.ForeignKey(User, related_name='members', default=-1, on_delete=models.CASCADE)
role = models.CharField(max_length=20, null=False, choices=TEAMROLES, default = 'member')

CollectionLink
--------------
collection = models.ForeignKey(Collection, default=None, on_delete=models.CASCADE, related_name='links')
label = models.CharField(null=True, blank=True, max_length=200)
uri = models.TextField(validators=[URLValidator()])
link_type = models.CharField(default='webpage', max_length=10, choices=LINKTYPES)
license = models.CharField(null=True, blank=True, max_length=64)

CollectionUser
--------------
collection = models.ForeignKey(Collection, related_name='collabs', default=-1, on_delete=models.CASCADE)
user = models.ForeignKey(User, related_name='collection_collab', default=-1, on_delete=models.CASCADE)
role = models.CharField(max_length=20, null=False, choices=TEAMROLES)

CollPlace
---------
collection = models.ForeignKey(Collection, related_name='annos', on_delete=models.CASCADE)
place = models.ForeignKey(Place, related_name='annos', on_delete=models.CASCADE)
sequence = models.IntegerField()
